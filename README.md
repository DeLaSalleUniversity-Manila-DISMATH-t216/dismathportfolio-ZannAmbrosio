# dismathportfolio-ZannAmbrosio
dismathportfolio-ZannAmbrosio created by Classroom for GitHub

Alec Zandra Mae H. Ambrosio 
DISMATH - EL

#Week 1 (Orientation + Introduction to DISMATH)
- I was introduced to a new and exciting subject, Discrete Mathematics.
- At first I thought that this would be a great term for me, but because of DISMATH, it is now the best.
- I had difficulty absorbing the topics at first, but at second and third glance to my notes, I was able to get it at last.
- We were taught about mathematical proofs, truth, truth tables, and logical connectives. 

#Week 2
- We were taught about Logical Equivalences.
- This part is really fun, because it's just like the operations in Algebra.
- We were able to do exercises on simplifying and evaluating statements using logical equivalences, and I sort of got the hang of it.
- We were also taught about predicate logic and quantifiers.
- I have learned that an **Existential Quantifier** means that there exist a true value in the possible values for a statement, while a **Universal Quantifier** means that the statement is true for all possible values.

#Week 3
- We were given the assignment to prove that superman does not exist.
- We were taught about Rules of Inference
- We tried answering different problems (ex. Problem about proving the conclusion that they will be home by sunset) using rules of inference and countercheck it with a truth table.
- We were taught about Modus Ponens, Modus Tollens, Hyphothetical Syllogism, Disjunctive syllogism, Addition, Simplification, Conjunction, and Resolution.

#Week 4
- During the first week, I thought it will be just pure fun, but at this point, I am doubting everything I have learned about the 
English language so far. I can't believe how something that sounds nonsense and illogical to the English language can actually have sense
and be logical.
- We were taught about methods of proof: direct proof, proof by contraposition, vacuous and trivial proof, and proof by contraposition.
- We were able to prove statements using these proofs and we were taught what method to use based on the statements as well.
- Proof by contraposition is entirely different from proof by contradiction. Sir Cabatuan emphasized that these two methods are the commonly
mistaken ones by students. **Proof by contraposition** deals with the contrapositive of the original statement. First, we have to assume that
not Q is true, then show that not P is also true, to prove that the statement is true. On the other hand, **Proof by Contradiction** deals with 
the whole statement's inverse as true. First, we have to assume that the inverse of statement A is true, and then we have to show that this 
leads to a contradiction, thus proving the original statement true.

#Week 5
- We finished with methods of proof.
- We were taught about Mathematical Induction. This one is pretty fun, but at the same time really confusing. 
- Mathematical Induction includes two steps: 1.) **Basis Step** 2.) **Direct Proof**. With this, we must first show that the statement is true by trying it on to the first value or the first perimeter of the statement. Then, if proven, we must do a direct proof. We then assume P(k) as true, then show P(k+1) is true as well to prove that the whole statement is true for all values.
- We were also taught about Recursive/Inductive definition, which is not a proof but only a definition.

#Week 6
- We were taught about program correctness, which I honestly didn't get that much. 
- With this, we we  taught about Hoare Triple: **p{S}q = T** wherein: p is the initial assertion, q is the final assertion and S is the program segment. This is used to prove wherein a certain program is true or not. This also can let a programmer check whether his/her program produces correct outputs or not. The procedures include: 1. Assume p = T, and 2. Substitute p to S, and show q = T, to prove the whole segment true. 
- We can also use the rules of inferences in checking for progra correctness.
- We were also taught about Zeno's Paradox and Power series this week. 
- We were introduced to Set Theory. 


#Week 7
- We continued discussing about Set Theory - Diagrams, Symbols, Union, Intersection, Symmetric Difference, Set Identities, Subsets, Power Sets, and Cardinality.
- I have learned that Set Identities are just similar to Logical Equivalences, but only using **union** and **intersection** rather than **and** and **or**. They can both be used in proving if a proposition is true or not. 
- Given a set G, subset H is only valid if the elements found in H can also be found in G. 
- Power set P is a set of all subsets in a set S. It includes all the possible subsets of S, including all the possible pairing, and including the empty set {}. The number of elements in a subset can be computed using the equation 2^n, n being the number of elements in S. 
- Cardinality is the actual number of elements in a set.
- We were introduced to functions, and its different types.
- A function is one-to-one if all values of x corresponds to one value of y. A function is onto if the function has equal codomain and range. A function is bijective if it is one-to-one and onto at the same time. 

#Week 8
- No classes.

#Week 9
- We were introduced to Algorithms.
- This is the part that I wasn't really able to take in and understand well. However, I understand how the program works given the algorithm, but I just can't seem to create an algorithm for a program given the description, because I feel so confused when it is written on paper.
- Algorithms are finite series of precise instructions or performing a computation or for solving a problem. 
- We were taught about the properties of algorithms.
    1. Input - There should be an input.
    2. Output - There should be an output.
    3. Definite - It does not use english sentences; must be understood by all.
    4. Correctness - Should produce correct output.
    5. Finite - It should have finite number of steps.
    6. General - It should use variables, and must be applicable to all problems of the same type.
- We were also taught the Maximum Element Algorithm, Linear Search Algorithm, and Binary Search Algorithm.

#Week 10
- We were taught about the sorting algorithms and the greedy algorithm. 
- Sorting algorithm includes the bubble sort algorithm and the insertion sort algorithm.
- Bubble sort algorithm states that for an input of a set, the comparisons would loop, until the set would have an output of elements in increasing order. The idea behind this algorithm is that the highest element would float from its initial position to the top, and the second highest will float as well from its initial position but only until below the highest, because the highest will float above it, and this is sort of similar to bubbles in the ocean rising up, as what we see. 
- Insertion sort algorithm states that for an input of a set, it would compare the elements one by one, until the set would have an output of elements in increasing order. For example, it would first allocate the first element as the first element in the new set, then it would compare it to the second element in the initial set. If the second element is greater than the first, it would swap, else, it would retain position. Next, the second element is included in the new set, and the second element would now be compared to the third and same rules apply: if greater than, swap, else, retain. 
- Greedy algorithm has a practical application of giving change by a machine. It can calculate for the minimum coins given the denominations or to calculate the change given a input money and actual price.

#Week 11
- We were taught about the growth of functions. Growth of functions is a limit of a given function. It can also be used to determine complexity.
- Growth of functions approximation:
    1. Big O Notation
    2. Big Theta Notation
    3. Big Omega Notation
- Big-O notation ( check only upper bound ): |a(x)| <= C|b(x)| where x>k, wherein a and b are functions, and C is a constant multiplied to a function to check whether it would overtake at a certain value or not. 
- Big-Omega notation ( check only lower bound ): C|g(x)| <= |f(x)| where x>k.
- Big-Theta notation ( check both lower bound and upper bound ): C|g(x)| <= |f(x)| <= C|g(x)|
- We were also taught about time complexities.

#Week 12
- No classes.

#Week 13
- Graph Theory was introduced. I really like this topic because it trains my visual and analytical skills at the same time.
- Graphs are discrete structures consisting of vertices and edges.
- We were taught how to draw graphs given descriptions, and write it in G = {V, E} form, and also in matrix form. 
- The degree of a vertex is the nuber of edges incident with it. A loop contributes twice to the degree of the given vertex.
- **Handshaking Theorem** 
    - Let G = {V, E} be an undirected graph with e edges: 
        2e = Summation of degree of vertices (vertices)
- Euler Circuits and Paths
    - Euler Circuit: Graph must have even nodes
    - Euler Path: Odd nodes, node with odd degree
- Hamilton Circuits and Paths
    - Hamilton Circuit: All nodes must be covered, and you must be able to return to initial position.
    - Hamilton Path: All nodes must be covered.
    - If there is a pendant, automatically there is no circuit. **Pendant** is a node with one degree.
- Isomorphism of graphs is when two graphs are the same in connection, but different in appearance. One must check whether all the connections in both graphs are the same. If you already see one node with a degree that is not found in the other graph, then the two graphs are already considered not isomorphic. You can also check the matrices of each graphs to check whether they are isomorphic or not.
- Regions can be computed using this formula:
    - regions = edges - vertices + 2
- Graphs are considered planar if they don't have a K(3,3) or K(5) subset according to Kuratowski's Theorem.

#Week 14
- We were introduced to color theorem. The maximum color of a planar graph is 4. 
- The number of colors in a complete graph K, is the same as the number of nodes. The number of colors in a cycle C, when vertices are even is 2 and 3 when it is odd. The number of colors in a wheel W, when vertices are even is 3 and 4 when it is odd.
- We were also introduced to trees, which are connected undirected graphs without circuits. It is a data structure with a set of linked nodes.
- A rooted tree a tree in which one of the nodes has been assigned as the root and every edge is directed away from the root. In this kind of tree, one can identify the parent, the children, the sibling, ancestor, descendant, internal vertices, and the leaves.
- An M-ary root tree if every internal vertex has no more than m children. A full M-ary root tree is when **all** internal vertices have m children. 
- An ordered root tree is when all children of all internal vertices is ordered.
- We were also introduced to grammar and language. We use a derivation tree to check validity of grammar
- Automata theory studies the law of computation.
- Finite automation provides the simplest model of computing device, based on the concept of states.
- Lexical analysis is the process where the stream of characters making up the source program is read from left to right and grouped into tokens.
- The last topic is about the finite-state machine. Which is basically a graph that connects the states inputs and outputs, and somewhat tell what the program would do given different situations.
    - Finite-state machine: M = {S, I, O, f, g, s(0)}, where S = states, I = input, O = output, f =function, g = function output and s(0) = initial state.

#Week 15
- Project Submission (April 13, 2016)
- Finals Week!! (April 14, 2016)

#Reading Assignments
- Tree Traversal
    - The process of visiting every element in a tree, exactly once.
- Spanning Trees
    - A connected subgraph in which there are no cycles.
    - A tree that contains every vertex of a certain graph.
- Relations and Their Properties
    - Reflexive Property: A relation is reflexive if every element in G is connected to itself. Must contain pairs (a, a) or (b, b).
    - Symmetric Property: A relation is symmetric if a is related to b as b is related to a. Must contain pairs (a, b) and (b,a).
    - Transitive Property: A relation is transitive if it contains pairs (a, b), (b, c), and (a, c) 
- N-ary relations and applications
    - An n-ary relation involves n sets and can be described by a set of n-tuples. 
    - N-ary relations can also be applied to databases. 
- Representing Relations
    - One can represent a relation by:
        1. Ordered Pairs
        2. Tables
        3. Graphs
        4. Mapping
- Closure of Relations
    - The closure of a relation R with respect to property P is the relation obtained by adding the minimum number of ordered pairs to R to obtain property P.
    - Reflexive Closure: add loops
    - Symmetric Closure: add arcs in opposite direction
    - Transitive Closure: if there is a path from a to b, add an arc from a to b.
- Equivalence Relations
    - A relation is considered an equivalence relation if it is symmetric, transitive and reflexive.
- Partial Orderings
    - A relation R on a set S is called a partial order if it is reflexive, antisymmetric and transitive.
